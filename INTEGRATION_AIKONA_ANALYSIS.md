# Анализ интеграции с API Айконы для получения фактических выполненных работ

## Текущая ситуация

**Ваша система (дашборд):**
- Объекты находятся в контейнерах (SetlGroup, ГСН, ФСК)
- У каждого объекта есть СМР (виды работ, например "СТК. Внутренние стены")
- У каждого СМР есть счетчики: `count` (сгенерировано актов вручную) и `total` (всего должно быть)
- Сейчас: `total` вводится вручную пользователем
- Формат отображения: "4 из 5" (4 сгенерировано, 5 должно быть)

**Система Айкона:**
- Отслеживает фактические выполненные работы на стройке
- Обновляет отчет ER32 раз в сутки в 5:00
- API возвращает данные о выполненных работах по объектам
- Объектов в Айконе много, в вашей системе пока мало (пилотные объекты)

## Проблема: Как связать объекты?

**Главный вопрос:** Как система поймет, какой объект из Айконы соответствует объекту в вашем дашборде?

### Варианты решения

---

## ВАРИАНТ 1: Ручная привязка через идентификаторы (ПРОСТОЙ)

### Как работает:
1. В вашей системе добавляется поле `aikona_object_id` (или `aikona_construction_id`) для каждого объекта
2. Администратор вручную указывает, какой ID объекта из Айконы соответствует объекту в дашборде
3. Система ежедневно в 7:00 запрашивает API Айконы и обновляет только те объекты, у которых указан `aikona_object_id`

### Что нужно сделать:

**1. Изменения в базе данных:**
```sql
ALTER TABLE objects ADD COLUMN aikona_object_id INTEGER;
ALTER TABLE objects ADD COLUMN aikona_sync_enabled BOOLEAN DEFAULT false;
```

**2. Изменения в UI:**
- В форме редактирования объекта добавить поле "ID объекта в Айконе" (только для админа)
- Чекбокс "Синхронизировать с Айконой"

**3. Backend скрипт синхронизации:**
```javascript
// backend/scripts/sync-aikona.js
async function syncAikonaData() {
  // 1. Получаем все объекты, у которых включена синхронизация
  const objects = await getObjectsWithSync();
  
  // 2. Запрашиваем API Айконы для каждого объекта
  for (const object of objects) {
    const aikonaData = await fetchAikonaAPI(object.aikona_object_id);
    
    // 3. Обновляем поле total для каждого СМР
    if (aikonaData && aikonaData.stk) {
      object.generatedActs.forEach(smr => {
        // Ищем соответствующий СМР по названию или коду
        const aikonaSMR = findMatchingSMR(aikonaData.stk, smr.name);
        if (aikonaSMR) {
          smr.total = aikonaSMR.completed_count; // Обновляем total из Айконы
        }
      });
      
      await updateObject(object);
    }
  }
}
```

**4. Планировщик задач (cron job):**
```javascript
// Запускать ежедневно в 7:00
const cron = require('node-cron');
cron.schedule('0 7 * * *', async () => {
  console.log('Начинаем синхронизацию с Айконой...');
  await syncAikonaData();
  console.log('Синхронизация завершена');
});
```

### Плюсы:
- ✅ Простая реализация (2-3 дня работы)
- ✅ Полный контроль: вы сами выбираете, какие объекты синхронизировать
- ✅ Безопасно: не затронет объекты без привязки
- ✅ Можно тестировать постепенно (по одному объекту)

### Минусы:
- ⚠️ Нужно вручную привязать объекты (но их пока мало, это не проблема)
- ⚠️ Если объект изменит название в Айконе, привязка может сломаться
- ⚠️ Нужно будет сопоставлять названия СМР между системами

### Сложность реализации: **НИЗКАЯ** ⭐⭐

---

## ВАРИАНТ 2: Автоматическое сопоставление по названию объекта (СРЕДНИЙ)

### Как работает:
1. Система пытается найти объекты из Айконы по названию (частичное совпадение)
2. Если найдено несколько совпадений - показывается список для выбора
3. Если найдено одно точное совпадение - автоматически привязывается

### Что нужно сделать:

**1. Функция поиска совпадений:**
```javascript
async function findMatchingAikonaObjects(dashboardObject) {
  // Получаем все объекты из Айконы
  const aikonaObjects = await fetchAllAikonaObjects();
  
  // Ищем совпадения по названию
  const matches = aikonaObjects.filter(aikona => {
    const dashboardName = dashboardObject.name.toLowerCase();
    const aikonaName = aikona.construction_name.toLowerCase();
    
    // Проверяем различные варианты совпадений
    return aikonaName.includes(dashboardName) || 
           dashboardName.includes(aikonaName) ||
           calculateSimilarity(dashboardName, aikonaName) > 0.7;
  });
  
  return matches;
}
```

**2. UI для подтверждения:**
- При первом запуске синхронизации показывать список возможных совпадений
- Пользователь выбирает правильный объект из списка
- Система запоминает выбор

### Плюсы:
- ✅ Меньше ручной работы
- ✅ Можно автоматически обновлять при изменении названий

### Минусы:
- ⚠️ Может ошибиться при нескольких похожих названиях
- ⚠️ Нужна логика нечеткого поиска (библиотека типа `fuse.js`)
- ⚠️ Более сложная реализация

### Сложность реализации: **СРЕДНЯЯ** ⭐⭐⭐

---

## ВАРИАНТ 3: Сопоставление СМР по кодам (ТОЧНЫЙ, но сложный)

### Как работает:
1. В обеих системах используются стандартные коды СМР (например, "СТК_ВНУТРЕННИЕ_СТЕНЫ")
2. Создается справочник соответствия: код СМР → название
3. Система обновляет `total` по коду СМР, а не по названию

### Что нужно сделать:

**1. Справочник кодов СМР:**
```javascript
const SMR_CODES = {
  'СТК_КЛАДКА_НАРУЖНЫХ_СТЕН': {
    code: 'СТК_КЛАДКА_НАРУЖНЫХ_СТЕН',
    name: 'СТК. Кладка наружных стен',
    aikonaField: 'id_stk_1' // поле в ответе API Айконы
  },
  'СТК_ВНУТРЕННИЕ_СТЕНЫ': {
    code: 'СТК_ВНУТРЕННИЕ_СТЕНЫ',
    name: 'СТК. Внутренние стены и перегородки',
    aikonaField: 'id_stk_2'
  },
  // ...
};
```

**2. В базе данных:**
```sql
ALTER TABLE smrs ADD COLUMN code VARCHAR(50) UNIQUE;
```

**3. Сопоставление по коду:**
```javascript
function matchSMRByCode(dashboardSMR, aikonaData) {
  const code = dashboardSMR.code;
  const smrConfig = SMR_CODES[code];
  if (!smrConfig) return null;
  
  // Ищем в данных Айконы по коду
  const aikonaSMR = aikonaData.stk.find(s => s.id === smrConfig.aikonaField);
  return aikonaSMR ? aikonaSMR.completed_count : null;
}
```

### Плюсы:
- ✅ Точное сопоставление, без ошибок
- ✅ Работает даже при изменении названий
- ✅ Масштабируемо для многих объектов

### Минусы:
- ⚠️ Нужно поддерживать справочник кодов
- ⚠️ Нужно узнать точную структуру ответа API Айконы
- ⚠️ Если в Айконе нет нужного кода - не сработает
- ⚠️ Более сложная архитектура

### Сложность реализации: **ВЫСОКАЯ** ⭐⭐⭐⭐

---

## ВАРИАНТ 4: Гибридный подход (РЕКОМЕНДУЕТСЯ)

### Как работает:
1. **Для пилотных объектов** (их мало сейчас) - ручная привязка (Вариант 1)
2. **Для будущего масштабирования** - добавляем поддержку кодов СМР (Вариант 3), но не обязательно сразу
3. Система работает так:
   - Если у объекта есть `aikona_object_id` - синхронизируем
   - Если нет - показываем "Не синхронизируется с Айконой"
   - Пользователь может вручную вводить `total`, как сейчас

### Реализация поэтапно:

**Этап 1 (сейчас, 2-3 дня):**
- Добавить поле `aikona_object_id` в объекты
- Создать скрипт синхронизации
- Добавить UI для привязки объектов
- Настроить cron на 7:00
- Для сопоставления СМР использовать поиск по названию (простой вариант)

**Этап 2 (по необходимости, когда объектов станет много):**
- Добавить справочник кодов СМР
- Улучшить точность сопоставления
- Добавить автоматическое сопоставление объектов по названию

### Плюсы:
- ✅ Начинаем с простого
- ✅ Можно масштабировать по мере необходимости
- ✅ Не блокирует текущую работу
- ✅ Минимальные риски

### Минусы:
- ⚠️ Первоначальная ручная привязка для каждого объекта

### Сложность реализации: **НИЗКАЯ → СРЕДНЯЯ** ⭐⭐→⭐⭐⭐

---

## Что нужно для реализации (любой вариант)

### 1. Доступ к API Айконы:
- URL API (из скриншота: `https://icona.setl.ru/rest_api/swagger/docs/v1`)
- Endpoint для получения данных (например: `/api/ER32`)
- API ключ для авторизации (`api_key`)
- Структура ответа API (нужно посмотреть реальный ответ)

### 2. Структура ответа API (нужно уточнить):
```json
{
  "id_construction": 123,           // ID объекта в Айконе
  "construction_name": "Ривьера",   // Название объекта
  "stk": [                          // Массив выполненных работ
    {
      "id": 1,                      // ID работы
      "id_parent": 0,
      "completed_count": 5          // ВЫПОЛНЕНО фактически (это нужно для total)
    }
  ]
}
```

### 3. Технические требования:
- Backend: скрипт синхронизации (Node.js)
- Планировщик задач: `node-cron` или системный cron
- База данных: добавить поля для связи с Айконой
- Логирование: вести журнал всех синхронизаций

---

## Рекомендация

**Для вашей текущей ситуации (мало объектов, пилотный проект):**

### Использовать ВАРИАНТ 1 (Ручная привязка) или ВАРИАНТ 4 (Гибридный)

**Почему:**
1. ✅ Быстро реализовать (2-3 дня)
2. ✅ Низкие риски
3. ✅ Вы контролируете, какие объекты синхронизируются
4. ✅ Можно тестировать постепенно
5. ✅ Когда объектов станет больше - можно улучшить до Варианта 3

**Что делать дальше:**
1. Получить доступ к API Айконы и проверить реальную структуру ответа
2. Выбрать один объект для тестирования
3. Реализовать простой вариант синхронизации
4. Протестировать на одном объекте
5. Если работает - масштабировать

---

## Сравнительная таблица

| Критерий | Вариант 1 (Ручная) | Вариант 2 (Авто-поиск) | Вариант 3 (По кодам) | Вариант 4 (Гибрид) |
|----------|-------------------|------------------------|----------------------|-------------------|
| **Время реализации** | 2-3 дня | 4-5 дней | 5-7 дней | 2-3 дня (этап 1) |
| **Сложность** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐→⭐⭐⭐ |
| **Точность** | ✅ Высокая | ⚠️ Средняя | ✅ Очень высокая | ✅ Высокая |
| **Ручная работа** | ⚠️ Да (но объектов мало) | ✅ Минимум | ✅ Минимум | ⚠️ Да (этап 1) |
| **Масштабируемость** | ⚠️ Средняя | ✅ Хорошая | ✅ Отличная | ✅ Отличная |
| **Риски** | ✅ Низкие | ⚠️ Средние | ⚠️ Средние | ✅ Низкие |

---

## Вопросы для уточнения

1. **Структура API Айконы:**
   - Какой точный endpoint для получения данных по объекту?
   - Какая структура ответа? (нужен реальный пример)
   - Как передается `api_key`? (в header или query parameter?)

2. **Сопоставление СМР:**
   - Названия СМР в Айконе совпадают с вашими?
   - Есть ли коды СМР в ответе API?
   - Как идентифицировать нужный СМР в массиве `stk`?

3. **Объекты:**
   - Сколько сейчас объектов в вашей системе? (для оценки объема ручной работы)
   - Планируется ли масштабирование на все объекты из Айконы?

4. **Альтернатива:**
   - Может быть, проще пока вручную проставлять `total`?
   - Сколько времени это занимает сейчас?
   - Сколько объектов планируется добавить?

---

## Вывод

**Если объектов < 10:** Проще пока вручную проставлять `total`, автоматизация может не окупиться.

**Если объектов 10-50:** Использовать **Вариант 1 или 4** - быстрая реализация с минимальными рисками.

**Если объектов > 50:** Использовать **Вариант 4** с поэтапным развитием до Варианта 3.

**Мое мнение:** С учетом того, что объектов пока мало и это пилотный проект, **Вариант 4 (Гибридный)** - оптимальный выбор. Начинаем с простого, масштабируем по необходимости.

